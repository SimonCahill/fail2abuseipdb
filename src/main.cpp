/**
 * @file main.cpp
 * @author Simon Cahill (simon@simonc.eu)
 * @brief Contains the main application logic.
 * @version 0.1
 * @date 2022-10-07
 * 
 * @copyright Copyright (c) 2022 Simon Cahill
 */

#include <algorithm>
#include <exception>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <iterator>
#include <map>
#include <string>
#include <vector>

#include <nlohmann/json.hpp>
#include <fmt/format.h>

#include <getopt.h>
#include <unistd.h>

#include "string_splitter.hpp"
#include "version.hpp"

namespace fs = std::filesystem;

using fmt::format;

using nlohmann::json;

using defcat_t = std::vector<int32_t>;
using lookup_t = std::map<std::string, int32_t>;
using std::cerr;
using std::cin;
using std::cout;
using std::endl;
using std::error_code;
using std::exception;
using std::ifstream;
using std::istreambuf_iterator;
using std::map;
using std::ofstream;
using std::string;
using std::string_view;
using std::system_error;
using std::transform;
using std::vector;

// prototypes
static constexpr string_view getShortArgs(); //!< Gets the short string of args for getopt_long
static const option* getOptions(); //!< Gets the array of options for getopt_long

using svec_t = vector<string>;

static bool     alreadyReported(const string&); //!< Indicates whether or not an IP has already been reported
static bool     dumpF2bToFile(); //!< Dumps fail2ban's output to a file before attempting to read it back through parseFail2BanFromFile()
static bool     findFail2Ban(); //!< Attempts to find fail2ban-client in the system's $PATH
static bool     outputCsv(const json&); //!< Dumps the CSV-encoded data to the terminal
static bool     parseArgs(int32_t argc, char** argv); //!< Parses the application arguments
static bool     parseFail2BanFromFile(); //!< Parses fail2ban output from a given file
static bool     parseFail2BanFromStdIn(); //!< Parses fail2ban output from stdin
static string   exec(const string&, int32_t&); //!< Executes a program and returns the output
static string   getCategoriesForJail(); //!< Gets the categories for the currently selected jail
static svec_t   getLinesFromJson(const json&, const string&); //!< Gets a CSV-formatted line from a JSON object
// static void     cacheReportedIp(const string&); //!< Stores the reported IP into a cache file
static void     printHelpText(const string&); //!< Prints the help text to the terminal
static void     transformFail2BanInput(string&); //!< Transforms the fail2ban output to valid JSON

// globals
static bool     g_readFromFile = false; //!< Whether or not to read f2b input from a file
static bool     g_readFromStdIn = false; //!< Whether or not to read f2b input from stdin

/**
 * @brief Category lookup table
 */
static map<string, int32_t> 
                g_categoryLookup = {
    { "sshd",                   22 },
    { "apache-auth",            21 },
    { "apache-batbots",         19 },
    { "apache-overflows",       21 },
    { "apache-nohome",          21 },
    { "apache-fakegooglebot",   19 },
    { "apache-modsecurity",     21 },
    { "apache-shellshock",      21 },
    { "php-url-fopen",          21 },
    { "roundcube-auth",         21 },
    { "postfix",                -1 },
    { "sendmail-auth",          20 },
    { "sendmail-reject",        -1 },
    { "dovecot",                -1 },
    { "mysqld-auth",            21 },
    { "pam-generic",            20 },
    { "postfix-flood-attack",   04 }
};

/**
 * @brief Default categories for each entry
 */
static defcat_t g_defaultCategories = {
    15, 18
};

static string   g_cacheFile = "/tmp/f2abipdb.cache"; //!< [[unused currently]] The path to the cache file
static string   g_fail2banExe = ""; //!< The path to the fail2ban-client executable
static string   g_fileToRead = "fail2ban.json"; //!< The file to read input from
static string   g_jailName = ""; //!< The name of the jail (if specific jail exported from f2b)
static string   g_reportComment = "IP banned by fail2ban; banned in jail {0}. Report generated by fail2abuseipdb.";

// main
int main(int32_t argc, char** argv) {
    if (!parseArgs(argc, argv)) { return 0; }

    int32_t rval = 0;

    if (g_readFromFile) {
        rval = parseFail2BanFromFile() ? 0 : 1;
    } else if (g_readFromStdIn) {
        rval = parseFail2BanFromStdIn() ? 0 : 2;
    } else {
        if (getuid() != 0) {
            cerr << "Insufficent permissions! To execute fail2ban directly, elevated permissions are required." << endl;
            return 4;
        }
        if (g_fail2banExe.empty()) {
            cerr << "Searching for fail2ban..." << endl;
            cerr << "!! WARNING !! Search may or may not be broken!" << endl; // TODO: Remove when bug fixed
            if (!findFail2Ban()) {
                cerr << "Failed to find fail2ban! Aborting." << endl;
                return 3;
            }
        }
        if (!dumpF2bToFile()) {
            cerr << "Failed to get output from fail2ban" << endl;
            return 3;
        }

        rval = parseFail2BanFromFile() ? 0 : 3;
    }

    return rval;
}

/**
 * @brief [[Not implemented]] Whether or not an IP has previously been reported.
 * 
 * @remarks Reserved for future use
 * 
 * @param ip The IP to check against
 * 
 * @return true If the IP has previously been reported.
 * @return false Otherwise.
 */
bool alreadyReported(const string& ip) {
    return false;
}

/**
 * @brief Dumps fail2ban's output to a file
 * 
 * @return true If dumping was successful.
 * @return false Otherwise.
 */
bool dumpF2bToFile() {
    int32_t returnCode = 0;
    g_fileToRead = fmt::format("{0:s}/{1:d}.f2b", fs::temp_directory_path().string(), time(nullptr));
    exec(fmt::format(R"({0:s} banned 2>/dev/null > {1:s})", g_fail2banExe, g_fileToRead), returnCode);

    return returnCode == 0;
}

/**
 * @brief Attempts to find fail2ban-client on the system-
 * 
 * @return true If the executable was found.
 * @return false Otherwise. 
 */
bool findFail2Ban() {
    const static string PATH = "PATH";
    const static string FAIL2BAN_EXE = "fail2ban-client";

    if (getenv(PATH.c_str()) == nullptr) { return false; }

    string pathVar{};
    {
        auto pathCharPtr = getenv(PATH.c_str());
        pathVar = string(pathCharPtr, strnlen(pathCharPtr, 4096));
    }

    for (const auto path : StringSplit(pathVar, ":")) {
        const auto iterator = fs::directory_iterator(path);
        const auto iteratorEnd = fs::directory_iterator();
        const auto iterPosition = std::find_if(iterator, iteratorEnd, [&](const auto& file) {
            return file.is_regular_file() && file.path().filename() == FAIL2BAN_EXE;
        });

        if (iterPosition != iteratorEnd) {
            g_fail2banExe = iterPosition->path().string();
            return true;
        }
    }

    return false;
}

/**
 * @brief Parses the f2b input from the file pointed to by @see g_fileToRead
 * 
 * @return true If the file was read correctly.
 * @return false Otherwise.
 */
bool parseFail2BanFromFile() {
    bool rval = true;

    string fileContents{};
    json entries;

    if (!fs::exists(g_fileToRead) || !fs::is_regular_file(g_fileToRead)) {
        cerr << "File " << g_fileToRead << " cannot be read! Aborting..." << endl;
        rval = false;
        goto Exit;
    }
    {
        ifstream fStream(g_fileToRead, ifstream::openmode::_S_in);
        if (!fStream.good()) {
            cerr << "Failed to open file " << g_fileToRead << ". Aborting..." << endl;
            rval = false;
            goto Exit;
        }
        fStream.unsetf(std::ios_base::skipws);
        vector<char> buffer((istreambuf_iterator<char>(fStream)), (istreambuf_iterator<char>()));
        fileContents = string(buffer.begin(), buffer.end());
    }

    transformFail2BanInput(fileContents);
    try {
        entries = json::parse(fileContents);
    } catch (const exception& ex) {
        cerr << "Failed to parse JSON! Invalid format?" << endl
             << "Error description: " << ex.what() << endl;
        rval = false;
        goto Exit;
    }

    rval = outputCsv(entries);

    Exit:
    return rval;
}

/**
 * @brief Attempts to read input from fail2ban from stdin.
 * 
 * @return true If everything was successful.
 * @return false Otherwise.
 */
bool parseFail2BanFromStdIn() {
    bool rval = true;

    string f2bOutput{};
    json entries;

    for (string line{}; std::getline(cin, line);) {
        f2bOutput.append(line).append("\n");
    }

    if (f2bOutput.empty()) {
        rval = false;
        cerr << "Failed to read input from stdin!" << endl;
        goto Exit;
    }

    transformFail2BanInput(f2bOutput);
    try {
        entries = json::parse(f2bOutput);
    } catch (const exception& ex) {
        cerr << "Failed to parse JSON! Invalid format?" << endl
             << "Error description: " << ex.what() << endl;
        rval = false;
        goto Exit;
    }

    rval = outputCsv(entries);

    Exit:
    return rval;
}

/**
 * @brief Outputs the CSV-encoded data to the terminal.
 * 
 * @param entries A @see nlohmann::json object containing the f2b entries
 * 
 * @return true If CSV could be generated and printed.
 * @return false Otherwise
 */
bool outputCsv(const json& entries) {
    bool rval = true;

    const time_t timeNow = time(nullptr);
    struct tm tStruct{0};
    localtime_r(&timeNow, &tStruct);
    string timeString(256, 0);
    strftime(&timeString[0], timeString.size(), "%F %T%z", &tStruct);
    timeString.shrink_to_fit();

    vector<string> csvLines{
        "IP,Categories,ReportDate,Comment"
    };

    // I'm expecting an array of strings (complete jail output) or an array of string (specific fail output)
    if (!entries.is_array()) {
        cerr << "Invalid input. Expected array, got " << entries.type_name() << endl;
        rval = false;
        goto Exit;
    }

    {
        const auto newLines = getLinesFromJson(entries, timeString);
        csvLines.insert(csvLines.end(), newLines.begin(), newLines.end());
    }

    for (const auto& line : csvLines) {
        cout << line << endl;
    }

    Exit:
    return rval;
}

/**
 * @brief Gets all the lines (reported IPs) from the JSON resulting from fail2ban
 * 
 * @param entries The JSON to parse
 * @param timeString The current time
 * 
 * @return svec_t A vector of strings containing the IPs
 */
svec_t getLinesFromJson(const json& entries, const string& timeString) {
    vector<string> lines;
    string currentIp{};
    for (const auto& entry : entries) {
        // This should probably be split up,
        // but right now I can't be bothered.
        // As long as it works, I'm fine with it, I guess.
        // For now at least
        if (!entry.is_object() && entry.is_string()) {
            currentIp = entry.get<string>();

            if (alreadyReported(currentIp)) { continue; }

            // Specific jail output
            // We don't need to look anything up, just grab default cats and append to list
            lines.push_back(format(
                R"({0:s},"{1:s}",{2:s},"{3:s}")",
                currentIp,
                getCategoriesForJail(),
                timeString,
                format(g_reportComment, g_jailName.empty() ? "UNKNOWN" : g_jailName)
            ));
        } else if (entry.is_object()) {
            const auto& obj = entry.get<json::object_t>();
            g_jailName = obj.begin()->first;
            const auto newLines = getLinesFromJson(*entry.begin(), timeString);
            lines.insert(lines.end(), newLines.begin(), newLines.end());
        }
    }
    return lines;
}

/**
 * @brief Gets the categories set for a given jail
 * 
 * @return string A comma-separated string containing the abuseipdb categories.
 * 
 * @remarks Categories are listed [https://www.abuseipdb.com/categories](here)
 */
string getCategoriesForJail() {
    string categories{};
    for (size_t i = 0; i < g_defaultCategories.size(); i++) {
        if (i > 0) {
            categories.push_back(',');
        }

        categories.append(std::to_string(g_defaultCategories[i]));
    }

    const auto posInMap = std::find_if(g_categoryLookup.begin(), g_categoryLookup.end(), [](const auto x) {
        return x.first == g_jailName;
    });

    if (posInMap != g_categoryLookup.end() && posInMap->second != -1) {
        categories.append(format(",{0:d}", posInMap->second));
    }

    return categories;
}

// other impl
/**
 * @brief Parses the command-line arguments sent to the application.
 * 
 * @param argc The amount of args passed.
 * @param argv An array of strings containing the arguments.
 * 
 * @return true If application execution should continue.
 * @return false If the application should halt.
 */
bool parseArgs(int32_t argc, char** argv) {
    bool rVal = true;

    int32_t curIdx = 0;
    char optVal = 0;

    if (argc == 1) {
        goto UglyHelp;
    }

    while ((optVal = getopt_long(argc, argv, getShortArgs().data(), getOptions(), &curIdx)) != -1) {
        switch (optVal) {
            case 'h':
            UglyHelp:
                printHelpText(argv[0]);
                rVal = false;
                goto Exit;
            case 's':
                g_readFromStdIn = true;
                break;
            case 'f':
                g_readFromFile = true;
                if (optarg == nullptr) {
                    cerr << "Warning: will use default file " << g_fileToRead << "." << endl;
                } else {
                    g_fileToRead = optarg;
                }
                break;
            case 'v':
                cerr << "Not yet implemented. Sorry." << endl;
                break;
            case 'c':
                if (optarg == nullptr) {
                    cerr << "Error: missing required argument for comment!" << endl;
                    break;
                }
                g_reportComment = optarg;
                break;
            case 'j':
                if (optarg == nullptr) {
                    cerr << "Error: missing required argument for jail name!" << endl;
                    break;
                }
                g_jailName = optarg;
                break;
            case 'e':
                if (optarg == nullptr) {
                    cerr << "Error: missing required argument for fail2ban executable!" << endl;
                    break;
                }
                g_fail2banExe = optarg;
                break;
        }
    }

    Exit:
    return rVal;
}

/**
 * @brief Executes a command on the current system and returns both output and exit code.
 * 
 * @param cmd The command to execute.
 * @param returnCode The return code of the executed command.
 * 
 * @return string The output of the executed command.
 */
string exec(const string& cmd, int32_t& returnCode) {
    string commandOutput;

    FILE* pipe = popen(cmd.c_str(), "r");

    if (!pipe) {
        // you'd have to throw a system_error or something here; or just remove the exception
        throw system_error(error_code(errno, std::generic_category()), "Failed to start process!");
    }

    try {
        char outputBuffer[512] = {0};
        while (!feof(pipe) && fgets(outputBuffer, sizeof(outputBuffer) / sizeof(outputBuffer[0]), pipe) != NULL) {
            commandOutput += outputBuffer;
        }
    } catch (...) {
        returnCode = pclose(pipe);
        throw;
    }

    returnCode = pclose(pipe);
    return commandOutput;
}

/**
 * @brief Prints the help text to the console.
 * 
 * @param binName The name of the application (argv[0])
 */
void printHelpText(const string& binName) {
    const static string RAW = R"(
        {0} v{1} - A simple utility for converting fail2ban entries into an abuseipdb CSV format

        Usage:
            {0} -f[/path/to/file] # Use [file] to parse fail2ban jail contents
            {0} -% # to attempt to get output directly from fail2ban (requires elevated privileges!)
            {0} --stdin # to read input from stdin

        Arguments:
            --help, -h              Prints this text and exits
            --stdin, -s             Reads input from stdin
            --file=, -f[file]       Reads input from [file] or fail2ban.json if optarg is empty
            --version, -v           Prints the version information and exits
            --comment, -c[text]     Sets the value for the comment field. Variables are available below
            --jail-name, -j[jail]   Sets the name of the jail (useful if exporting specific jails from fail2ban)
            --f2b, -e[f2b-client]   Sets the location of the fail2ban-client executable (local system will not be searched)
            --call-f2b, -%          No, that's not a typo. Calls fail2ban directly. !! WARNING: REQUIRES ELEVATED PRIVILEGES. NOT RECOMMENDED !!

        Comment variables:
            {{0}}                   Jail name
            {{1}}                   Report time

        Exit codes:
            0                       Success
            1                       Failed to parse input from file
            2                       Failed to parse input from stdin
            3                       Failed to parse input from fail2ban exec
            4                       Insufficent execution rights
            5                       Could not find fail2ban-client
    )";

    cout << format(RAW, binName, getProjectVersion()) << endl;
}

/**
 * @brief Gets the short args required for getopt_long.
 * 
 * @return constexpr string_view The arg string.
 */
constexpr string_view getShortArgs() { return "hsf:vc:j:e:%"; }

/**
 * @brief Gets the array of options required for getopt_long.
 * 
 * @return const option* A const pointer to an array of @see option structs.
 */
const option* getOptions() {
    const static option OPTIONS[] = {
        { "help",       no_argument,        nullptr,    'h' },
        { "stdin",      no_argument,        nullptr,    's' },
        { "file",       optional_argument,  nullptr,    'f' },
        { "version",    no_argument,        nullptr,    'v' },
        { "comment",    required_argument,  nullptr,    'c' },
        { "jail-name",  required_argument,  nullptr,    'j' },
        { "f2b",        required_argument,  nullptr,    'e' },
        { "call-f2b",   no_argument,        nullptr,    '%' },
        { nullptr,      no_argument,        nullptr,     0  }
    };

    return OPTIONS;
}

/**
 * @brief Transforms fail2ban's output to a valid JSON.
 * 
 * @param input Raw fail2ban ouput.
 */
void transformFail2BanInput(string& input) {
    string output{};
    transform(input.begin(), input.end(), std::back_inserter(output), [&](const char c) {
        if (c == '\'') { return '"'; }
        return c;
    });

    input = output;
}

/**
 * @brief [[Unused / Reserved for future use]] Caches a recently reported IP.
 * 
 * @param ip The IP to cache.
 */
void cacheReportedIp(const string& ip) {
    ofstream cacheOutput(g_cacheFile, std::ios_base::openmode::_S_app);
    cacheOutput << ip << ":" << time(nullptr) << endl;
    cacheOutput.close();
}

